// automatically generated by Xtext
grammar org.xtext.genDSL2.gsl.Gsl with org.eclipse.xtext.common.Terminals

import "http://www.example.org/genDSL2" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

GenealogyTree returns GenealogyTree:
  'GenealogyTree'
  '{'
    'familyName' familyName=EString
    ('established' established=DateX)?
    ('persons' '{' person+=Person ( "," person+=Person)* '}' )?
  '}';






EString returns ecore::EString:
  STRING | ID;

DateX returns DateX:
  {DateX}
  //'DateX'
  '{'
    ('year' year=EInt)?
    ('month' month=EInt)?
    ('day' day=EInt)?
  '}';

Person returns Person:
	{Person}
//  'Person'
//  '{'
  givenName=EString
  '{'
    ('unknown' unknown=EBoolean)?
    ('birthPlace' birthPlace=EString)?
    ('deathPlace' deathPlace=EString)?
    ('restingPlace' restingPlace=EString)?
    ('type' type=TypeOfPerson)?
    ('gender' gender=Gender)?
    ('otherNames' '{' otherNames+=EString ( "," otherNames+=EString)* '}' )?
    ('nickname' nickname=EString)?
    ('deathCause' deathCause=EString)?
    ('birthDate' birthDate=DateX)?
    ('deathDate' deathDate=DateX)?
    ('personhistory' '{' personhistory+=PersonHistory ( "," personhistory+=PersonHistory)* '}' )?
    ('cohabitation' '{' cohabitation+=Cohabitation ( "," cohabitation+=Cohabitation)* '}' )?
    ('marriage' '{' marriage+=Marriage ( "," marriage+=Marriage)* '}' )?
  '}'
  ;

EInt returns ecore::EInt:
  '-'? INT;

enum TypeOfPerson returns TypeOfPerson:
        BIOLOGICAL = 'BIOLOGICAL' | ADOPTED = 'ADOPTED' | SEMIADOPTED = 'SEMIADOPTED' | MARRIED = 'MARRIED' | DISOWNED = 'DISOWNED' | ILLEGITIMATE = 'ILLEGITIMATE';

enum Gender returns Gender:
        MALE = 'MALE' | FEMALE = 'FEMALE' | BIGENDER = 'BIGENDER';

PersonHistory returns PersonHistory:
  {PersonHistory}
  'PersonHistory'
  //'{'
    ('gender' gender=Gender)?
    ('givenName' givenName=EString)?
    ('changed' changed=EDATE)?
  //'}'
  ;

Cohabitation returns Cohabitation:
  {Cohabitation}
  (legitimate?='legitimate')?
  'Cohabitation'
  '{'
    ('type' type=TypeOfIntimateRelationship)?
    ('partners' '(' partners+=[Person|EString] ( "," partners+=[Person|EString])* ')' )?
    ('children' '{' children+=Person ( "," children+=Person)* '}' )?
  '}'
  ;

Marriage returns Marriage:
  {Marriage}
  'Marriage'
  '{'
    ('type' type=TypeOfIntimateRelationship)?
    ('spouses' '(' spouses+=[Person|EString] ( "," spouses+=[Person|EString])* ')' )?
    ('fromDate' fromDate=DateX)?
    ('toDate' toDate=DateX)?
    ('children' '{' children+=Person ( "," children+=Person)* '}' )?
  '}'
  ;

EBoolean returns ecore::EBoolean:
  'true' | 'false';
  
  
//terminal fragment DIGIT: '0'..'9';

terminal EDATE returns ecore::EDate:
  ('0'..'9')('0'..'9')('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9');

//EDate returns ecore::EDate:
//  'EDate' /* TODO: implement this rule and an appropriate IValueConverter */;

enum TypeOfIntimateRelationship returns TypeOfIntimateRelationship:
        MONOGAMY = 'MONOGAMY' | POLYGAMY = 'POLYGAMY' | POLYFIDELITY = 'POLYFIDELITY';
