// automatically generated by Xtext
grammar org.xtext.example.gendsl.GenDsl with org.eclipse.xtext.common.Terminals

import "http://www.example.org/gENdsl" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

GenealogyTree returns GenealogyTree:
	'GenealogyTree'
	'{'
		'familyName' familyName=EString
		('established' established=DateX)?
		('persons' '{' person+=Person ( "," person+=Person)* '}' )?
	'}';






EString returns ecore::EString:
	STRING | ID;

DateX returns DateX:
	{DateX}
	'{'
		('year' year=EIntegerObject)?
		('month' month=EIntegerObject)?
		('day' day=EIntegerObject)?
	'}';

Person returns Person:
	givenName=EString
	//'{'
		&('unknown' unknown=EBoolean)? 
		&('birthPlace' birthPlace=EString)?
		&('deathPlace' deathPlace=EString)?
		&('restingPlace' restingPlace=EString)?
		&('type' type=TypeOfPerson)?
		&('gender' gender=Gender)?
		&('otherNames' '{' otherNames+=EString ( "," otherNames+=EString)* '}' )?
		&('nickname' nickname=EString)?
		&('deathCause' deathCause=EString)?
		&('marriages' '(' marriages+=[Marriage|EString] ( "," marriages+=[Marriage|EString])* ')' )?
		&('cohabitations' '(' cohabitations+=[Cohabitation|EString] ( "," cohabitations+=[Cohabitation|EString])* ')' )?
		&('birthDate' birthDate=DateX)?
		&('deathDate' deathDate=DateX)?
		&('personhistory' '{' personhistory+=PersonHistory ( "," personhistory+=PersonHistory)* '}' )?
		&('cohabitation' '{' cohabitation+=Cohabitation ( "," cohabitation+=Cohabitation)* '}' )?
		&('marriage' '{' marriage+=Marriage ( "," marriage+=Marriage)* '}' )?
	//'}'
	;

EIntegerObject returns ecore::EIntegerObject:
	'-'? INT;

enum TypeOfPerson returns TypeOfPerson:
				BIOLOGICAL = 'BIOLOGICAL' | ADOPTED = 'ADOPTED' | SEMIADOPTED = 'SEMIADOPTED' | MARRIED = 'MARRIED' | DISOWNED = 'DISOWNED' | ILLEGITIMATE = 'ILLEGITIMATE';

enum Gender returns Gender:
				MALE = 'MALE' | FEMALE = 'FEMALE' | BIGENDER = 'BIGENDER';

Marriage returns Marriage:
	{Marriage}
	'Marriage'
	//'{'
		('type' type=TypeOfIntimateRelationship)?
		('spouses' '(' spouses+=[Person|EString] ( "," spouses+=[Person|EString])* ')' )?
		('fromDate' fromDate=DateX)?
		('toDate' toDate=DateX)?
		('children' '{' children+=Person ( "," children+=Person)* '}' )?
	//'}'
	;

Cohabitation returns Cohabitation:
	{Cohabitation}
	(legitimate?='legitimate')?
	'Cohabitation'
	'{'
		('type' type=TypeOfIntimateRelationship)?
		('partners' '(' partners+=[Person|EString] ( "," partners+=[Person|EString])* ')' )?
		('children' '{' children+=Person ( "," children+=Person)* '}' )?
	'}';

PersonHistory returns PersonHistory:
	{PersonHistory}
	'PersonHistory'
	'{'
		('gender' gender=Gender)? 
		('givenName' givenName=EString)?
		('changed' changed=EDate)?
	'}';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

enum TypeOfIntimateRelationship returns TypeOfIntimateRelationship:
				MONOGAMY = 'MONOGAMY' | POLYGAMY = 'POLYGAMY' | POLYFIDELITY = 'POLYFIDELITY';

EDate returns ecore::EDate:
	'EDate' /* TODO: implement this rule and an appropriate IValueConverter */;
